<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Syn7h_</title> 
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            overscroll-behavior: none; 
            background-color: #1a202c; 
            color: #e2e8f0; 
        }
        .keyboard-container { width: 100%; overflow-x: auto; padding-bottom: 10px; }
        .keyboard { display: flex; justify-content: flex-start; align-items: flex-start; padding: 20px; background-color: #2d3748; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); position: relative; min-width: min-content; -webkit-user-select: none; -ms-user-select: none; user-select: none; }
        .key { border: 1px solid #4a5568; border-radius: 5px; cursor: pointer; display: flex; justify-content: center; align-items: flex-end; font-size: 10px; padding-bottom: 5px; transition: background-color 0.1s ease; box-sizing: border-box; }
        .white-key { background-color: #f7fafc; color: #2d3748; width: 38px; height: 170px; z-index: 1; margin-right: -1px; }
        .white-key:active, .white-key.active { background-color: #a0aec0; }
        .black-key { background-color: #2d3748; color: #cbd5e0; width: 26px; height: 100px; position: absolute; z-index: 2; border: 1px solid #1a202c; margin-left: -13px; }
        .black-key:active, .black-key.active { background-color: #4a5568; }
        
        .controls-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; width: 100%; max-width: 1400px; }
        .control-group { display: flex; flex-direction: column; align-items: stretch; padding: 12px; background-color: #2d3748; border: 1px solid #4a5568; border-radius: 8px; }
        .control-group label, .control-group .group-title { margin-bottom: 8px; font-size: 0.875rem; color: #a0aec0; font-weight: 600; text-align: center; text-transform: uppercase; letter-spacing: 0.05em;}
        .control-group select, .control-group button, .control-group input[type="range"], .control-group input[type="checkbox"], .control-group input[type="file"] { padding: 8px 6px; border-radius: 6px; border: 1px solid #4a5568; background-color: #1a202c; font-size: 0.875rem; cursor: pointer; color: #e2e8f0; width: 100%; box-sizing: border-box; margin-bottom: 4px; }
        .control-group input[type="file"] { padding: 4px; }
        .control-group input[type="checkbox"] { width: auto; align-self:center; height: 20px; padding:0; margin-bottom: 8px; accent-color: #f56565;}
        .control-group button { background-color: #f56565; color: #1a202c; font-weight: bold; border: none;}
        .control-group button:hover { background-color: #dd5858; }
        .control-group button.learn-active { background-color: #48bb78; color: #1a202c; }
        .control-group input[type="range"] { padding: 0; height: auto; accent-color: #f56565; }
        .control-group .button-group { display: flex; justify-content: space-around; }
        .control-group .button-group button { width: auto; padding: 6px 10px; }
        .value-display { font-size: 0.75rem; color: #718096; margin-top: 0px; text-align: center; height: 1.2em; }
        .hidden { display: none !important; }

        .message-box-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        .message-box-overlay.visible { opacity: 1; visibility: visible; }
        .message-box-content { background-color: #2d3748; padding: 25px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.5); text-align: center; color: #e2e8f0; border: 1px solid #4a5568;}
        .message-box-content button { margin-top: 15px; padding: 10px 20px; border-radius: 6px; background-color: #f56565; color: #1a202c; font-weight: bold; border: none; cursor: pointer; transition: background-color 0.2s ease;}
        .message-box-content button:hover { background-color: #dd5858; }
        
        #midi-status, #midi-learn-status { margin-top: 10px; padding: 8px; background-color: #2d3748; border-radius: 6px; text-align:center; font-size: 0.9em; color: #a0aec0; border: 1px solid #4a5568;}
        .instructions { font-size: 0.8em; color: #718096; margin-top:10px; text-align:center; }
        
        .title-container { display: flex; align-items: center; justify-content: center; margin-bottom: 1.5rem; }
        .logo { width: 60px; height: 60px; margin-right: 15px; stroke: #f56565; stroke-width: 2; fill: none; }
        .main-title { font-family: 'Orbitron', sans-serif; font-size: 2.8rem; color: #e2e8f0; text-shadow: 0 0 5px #f56565, 0 0 10px #f56565, 0 0 15px #f5656533; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col items-center justify-center p-4 select-none">

    <div class="w-full max-w-7xl mx-auto flex flex-col items-center">
        <div class="title-container">
            <svg class="logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <path d="M 80 20 C 80 10, 70 10, 60 10 S 40 10, 40 20 C 40 30, 50 30, 60 30 S 80 30, 80 40 C 80 50, 70 50, 60 50 S 40 50, 40 60 C 40 70, 50 70, 60 70 S 80 70, 80 80" stroke-linecap="round" stroke-linejoin="round"/>
                <polyline points="20 15, 45 15, 25 85" stroke-linecap="round" stroke-linejoin="round"/>
                <line x1="5" y1="95" x2="95" y2="95" stroke-width="1.5" stroke="#4a5568"/><line x1="15" y1="85" x2="85" y2="85" stroke-width="1" stroke="#4a5568"/>
                <line x1="50" y1="50" x2="50" y2="95" stroke-width="0.5" stroke="#4a5568"/><line x1="30" y1="65" x2="30" y2="95" stroke-width="0.5" stroke="#4a5568"/><line x1="70" y1="65" x2="70" y2="95" stroke-width="0.5" stroke="#4a5568"/>
            </svg>
            <h1 class="main-title">Syn7h_</h1>
        </div>

        <div class="controls-container mb-8">
            <!-- OSCILLATOR GROUP -->
            <div class="control-group">
                <span class="group-title">Oscillator & MIDI Learn</span>
                <button id="midi-learn-button" class="mb-2">MIDI Learn</button>
                <div id="midi-learn-status" class="text-xs mb-2 h-6"></div> 
                <label for="osc-type">Type</label>
                <select id="osc-type">
                    <option value="sine">Sine</option><option value="square">Square</option><option value="triangle">Triangle</option><option value="sawtooth">Sawtooth</option>
                    <option value="pwm">PWM</option><option value="fmsine">FM Sine</option><option value="amsine">AM Sine</option>
                    <option value="supersaw">Supersaw</option>
                    <option value="resonantbody">Resonant Body</option>
                    <option value="formantvoice">Formant Voice</option>
                    <option value="granular">Granular (Monophonic)</option> 
                </select>
                <div id="pwm-controls" class="hidden">
                    <label for="pwm-speed">PWM Speed</label><input type="range" id="pwm-speed" min="0.1" max="20" value="5" step="0.1"><span id="pwm-speed-display" class="value-display">5 Hz</span>
                </div>
                <div id="fm-controls" class="hidden"> 
                    <label for="fm-harmonicity">FM Harmonicity</label><input type="range" id="fm-harmonicity" min="0.1" max="10" value="1.5" step="0.1"><span id="fm-harmonicity-display" class="value-display">1.5</span>
                    <label for="fm-mod-index">FM Mod Index</label><input type="range" id="fm-mod-index" min="1" max="50" value="10" step="1"><span id="fm-mod-index-display" class="value-display">10</span>
                </div>
                <div id="supersaw-controls" class="hidden">
                    <label for="supersaw-count">Saw Count</label><input type="range" id="supersaw-count" min="2" max="10" value="3" step="1"><span id="supersaw-count-display" class="value-display">3</span>
                    <label for="supersaw-spread">Spread (cents)</label><input type="range" id="supersaw-spread" min="0" max="100" value="25" step="1"><span id="supersaw-spread-display" class="value-display">25 cents</span>
                </div>
                 <div id="resonantbody-controls" class="hidden">
                    <label for="resonantbody-harmonicity">FM Harm (Resonant)</label><input type="range" id="resonantbody-harmonicity" min="0.1" max="20" value="2.7" step="0.1"><span id="resonantbody-harmonicity-display" class="value-display">2.7</span>
                    <label for="resonantbody-mod-index">FM Index (Resonant)</label><input type="range" id="resonantbody-mod-index" min="1" max="100" value="20" step="1"><span id="resonantbody-mod-index-display" class="value-display">20</span>
                </div>
                <div id="formantvoice-controls" class="hidden">
                    <label for="formantvoice-harmonicity">FM Harm (Formant)</label><input type="range" id="formantvoice-harmonicity" min="0.1" max="5" value="1.2" step="0.1"><span id="formantvoice-harmonicity-display" class="value-display">1.2</span>
                    <label for="formantvoice-mod-index">FM Index (Formant)</label><input type="range" id="formantvoice-mod-index" min="1" max="30" value="5" step="1"><span id="formantvoice-mod-index-display" class="value-display">5</span>
                </div>
                <div id="granular-controls" class="hidden">
                    <label for="granular-file-input">Load WAV File</label>
                    <input type="file" id="granular-file-input" accept=".wav" class="text-xs">
                    <div class="flex items-center justify-around my-1"> 
                        <label for="granular-loop" class="text-sm mr-1">Loop</label><input type="checkbox" id="granular-loop" class="mr-2">
                        <label for="granular-reverse" class="text-sm mr-1">Reverse Grains</label><input type="checkbox" id="granular-reverse">
                    </div>
                    <label for="granular-loop-start">Loop Start</label><input type="range" id="granular-loop-start" min="0" max="1" value="0" step="0.01"><span id="granular-loop-start-display" class="value-display">0.00</span>
                    <label for="granular-loop-end">Loop End</label><input type="range" id="granular-loop-end" min="0" max="1" value="1" step="0.01"><span id="granular-loop-end-display" class="value-display">1.00</span>
                    <label for="granular-grain-size">Grain Size</label><input type="range" id="granular-grain-size" min="0.01" max="0.5" value="0.1" step="0.005"><span id="granular-grain-size-display" class="value-display">0.1 s</span>
                    <label for="granular-overlap">Overlap</label><input type="range" id="granular-overlap" min="-0.1" max="0.4" value="0.05" step="0.005"><span id="granular-overlap-display" class="value-display">0.05 s</span>
                    <label for="granular-detune">Detune (Spray)</label><input type="range" id="granular-detune" min="0" max="1200" value="0" step="10"><span id="granular-detune-display" class="value-display">0 cents</span>
                    <label for="granular-playback-rate">Playback Rate</label><input type="range" id="granular-playback-rate" min="0.1" max="4" value="1" step="0.05"><span id="granular-playback-rate-display" class="value-display">1.0x</span>
                    <p class="text-xs text-center mt-1 text-gray-400">Amp Env & Filter Env do not apply to Granular mode.</p>
                </div>
                <label for="octave-display-label">Starting Octave: <span id="octave-display">4</span></label>
                <div class="button-group mt-1">
                    <button id="octave-down-btn" class="opacity-50 cursor-not-allowed">-</button> 
                    <button id="octave-up-btn" class="ml-2 opacity-50 cursor-not-allowed">+</button>
                </div>
            </div>
            <!-- AMPLITUDE ENVELOPE GROUP -->
            <div class="control-group">
                <span class="group-title">Amplitude Envelope</span>
                <label for="amp-env-attack">Attack</label><input type="range" id="amp-env-attack" min="0.005" max="2" value="0.01" step="0.001"><span id="amp-env-attack-display" class="value-display">0.01 s</span>
                <label for="amp-env-decay">Decay</label><input type="range" id="amp-env-decay" min="0.01" max="2" value="0.1" step="0.01"><span id="amp-env-decay-display" class="value-display">0.1 s</span>
                <label for="amp-env-sustain">Sustain</label><input type="range" id="amp-env-sustain" min="0" max="1" value="0.4" step="0.01"><span id="amp-env-sustain-display" class="value-display">0.4</span>
                <label for="amp-env-release">Release</label><input type="range" id="amp-env-release" min="0.01" max="5" value="0.8" step="0.01"><span id="amp-env-release-display" class="value-display">0.8 s</span>
                 <label for="volume">Master Volume</label><input type="range" id="volume" min="-40" max="0" value="0" step="1"><span id="volume-display" class="value-display">0 dB</span> 
            </div>
            <!-- FILTER & FILTER ENVELOPE GROUP -->
            <div class="control-group">
                <span class="group-title">Filter & Envelope</span>
                <label for="filter-type">Filter Type</label> <select id="filter-type"> <option value="none">None (Bypass Filter)</option><option value="moog">Lowpass (-24dB 'Moog')</option><option value="ms20lp">Lowpass (-12dB 'MS-20')</option><option value="ms20hp">Highpass (-12dB 'MS-20')</option> <option value="bandpass12">Bandpass (-12dB)</option><option value="bandpass24">Bandpass (-24dB)</option><option value="notch12">Notch (-12dB)</option><option value="notch24">Notch (-24dB)</option><option value="allpass">Allpass</option> </select> 
                <label for="filter-cutoff">Cutoff (Base Freq)</label><input type="range" id="filter-cutoff" min="20" max="20000" value="15000" step="1"><span id="filter-cutoff-display" class="value-display">15000 Hz</span> 
                <label for="filter-resonance">Resonance (Q)</label><input type="range" id="filter-resonance" min="0.1" max="30" value="1" step="0.1"><span id="filter-resonance-display" class="value-display">1.0 Q</span> 
                <label for="filter-env-attack">Env Attack</label><input type="range" id="filter-env-attack" min="0.005" max="2" value="0.05" step="0.001"><span id="filter-env-attack-display" class="value-display">0.05 s</span>
                <label for="filter-env-decay">Env Decay</label><input type="range" id="filter-env-decay" min="0.01" max="2" value="0.2" step="0.01"><span id="filter-env-decay-display" class="value-display">0.2 s</span>
                <label for="filter-env-sustain">Env Sustain</label><input type="range" id="filter-env-sustain" min="0" max="1" value="0.5" step="0.01"><span id="filter-env-sustain-display" class="value-display">0.5</span>
                <label for="filter-env-release">Env Release</label><input type="range" id="filter-env-release" min="0.01" max="5" value="1" step="0.01"><span id="filter-env-release-display" class="value-display">1.0 s</span>
                <label for="filter-env-amount">Env Amount (Octaves)</label><input type="range" id="filter-env-amount" min="-7" max="7" value="3" step="0.1"><span id="filter-env-amount-display" class="value-display">3 oct</span>
            </div>
            <!-- LFO 1 GROUP -->
            <div class="control-group"> <span class="group-title">LFO 1</span> <label for="lfo1-enable" style="margin-bottom: 2px;">Enable</label><input type="checkbox" id="lfo1-enable"> <label for="lfo1-wave">Waveform</label> <select id="lfo1-wave"> <option value="sine">Sine</option><option value="square">Square</option><option value="triangle">Triangle</option><option value="sawtooth">Sawtooth</option> <option value="pulse">Pulse</option><option value="pwm">PWM</option> </select> <div id="lfo1-pulse-width-controls" class="hidden"> <label for="lfo1-pulse-width">Pulse Width</label><input type="range" id="lfo1-pulse-width" min="0.01" max="0.99" value="0.5" step="0.01"><span id="lfo1-pulse-width-display" class="value-display">0.5</span> </div> <div id="lfo1-pwm-freq-controls" class="hidden"> <label for="lfo1-pwm-freq">PWM Freq</label><input type="range" id="lfo1-pwm-freq" min="0.1" max="20" value="2" step="0.1"><span id="lfo1-pwm-freq-display" class="value-display">2 Hz</span> </div> <label for="lfo1-rate">Rate</label><input type="range" id="lfo1-rate" min="0.1" max="30" value="2" step="0.1"><span id="lfo1-rate-display" class="value-display">2 Hz</span> <label for="lfo1-depth">Depth</label><input type="range" id="lfo1-depth" min="0" max="1" value="0.5" step="0.01"><span id="lfo1-depth-display" class="value-display">0.5</span> <label for="lfo1-destination">Destination</label> <select id="lfo1-destination"> <option value="none">None</option><option value="pitch">Osc Pitch (Vibrato)</option><option value="filterCutoff">Filter Env BaseFreq</option><option value="amplitude">Amplitude (Tremolo)</option> </select> </div>
            <!-- EFFECTS -->
            <div class="control-group"><span class="group-title">Distortion</span><label for="dist-enable">Enable</label><input type="checkbox" id="dist-enable"><label for="dist-amount">Amount</label><input type="range" id="dist-amount" min="0" max="1" value="0.0" step="0.01"><span id="dist-amount-display" class="value-display">0.0</span><label for="dist-wet">Wet</label><input type="range" id="dist-wet" min="0" max="1" value="0.0" step="0.01"><span id="dist-wet-display" class="value-display">0.0</span></div>
            <div class="control-group"><span class="group-title">BitCrusher</span><label for="crusher-enable">Enable</label><input type="checkbox" id="crusher-enable"><label for="crusher-bits">Bits</label><input type="range" id="crusher-bits" min="1" max="16" value="8" step="1"><span id="crusher-bits-display" class="value-display">8 bits</span><label for="crusher-wet">Wet</label><input type="range" id="crusher-wet" min="0" max="1" value="0.0" step="0.01"><span id="crusher-wet-display" class="value-display">0.0</span></div>
            <div class="control-group"><span class="group-title">Ring Modulator</span><label for="ringmod-enable">Enable</label><input type="checkbox" id="ringmod-enable"><label for="ringmod-frequency">Mod Freq</label><input type="range" id="ringmod-frequency" min="1" max="2000" value="100" step="1"><span id="ringmod-frequency-display" class="value-display">100 Hz</span><label for="ringmod-wet">Wet</label><input type="range" id="ringmod-wet" min="0" max="1" value="0.0" step="0.01"><span id="ringmod-wet-display" class="value-display">0.0</span></div>
            <div class="control-group"><span class="group-title">Chorus</span><label for="chorus-enable">Enable</label><input type="checkbox" id="chorus-enable"><label for="chorus-rate">Rate</label><input type="range" id="chorus-rate" min="0.1" max="8" value="1.5" step="0.1"><span id="chorus-rate-display" class="value-display">1.5 Hz</span><label for="chorus-depth">Depth</label><input type="range" id="chorus-depth" min="0" max="1" value="0.7" step="0.01"><span id="chorus-depth-display" class="value-display">0.7</span><label for="chorus-feedback">Feedback</label><input type="range" id="chorus-feedback" min="0" max="0.9" value="0.2" step="0.01"><span id="chorus-feedback-display" class="value-display">0.2</span><label for="chorus-wet">Wet</label><input type="range" id="chorus-wet" min="0" max="1" value="0.0" step="0.01"><span id="chorus-wet-display" class="value-display">0.0</span></div>
            <div class="control-group"><span class="group-title">Phaser</span><label for="phaser-enable">Enable</label><input type="checkbox" id="phaser-enable"><label for="phaser-frequency">LFO Freq</label><input type="range" id="phaser-frequency" min="0.1" max="10" value="0.5" step="0.1"><span id="phaser-frequency-display" class="value-display">0.5 Hz</span><label for="phaser-octaves">Octaves</label><input type="range" id="phaser-octaves" min="1" max="8" value="3" step="0.1"><span id="phaser-octaves-display" class="value-display">3</span><label for="phaser-base-freq">Base Freq</label><input type="range" id="phaser-base-freq" min="100" max="1500" value="350" step="10"><span id="phaser-base-freq-display" class="value-display">350 Hz</span><label for="phaser-wet">Wet</label><input type="range" id="phaser-wet" min="0" max="1" value="0.0" step="0.01"><span id="phaser-wet-display" class="value-display">0.0</span></div>
            <div class="control-group"><span class="group-title">Delay</span><label for="delay-enable">Enable</label><input type="checkbox" id="delay-enable"><label for="delay-time">Time</label><input type="range" id="delay-time" min="0.01" max="1" value="0.25" step="0.01"><span id="delay-time-display" class="value-display">0.25 s</span><label for="delay-feedback">Feedback</label><input type="range" id="delay-feedback" min="0" max="0.9" value="0.3" step="0.01"><span id="delay-feedback-display" class="value-display">0.3</span><label for="delay-wet">Wet</label><input type="range" id="delay-wet" min="0" max="1" value="0.0" step="0.01"><span id="delay-wet-display" class="value-display">0.0</span></div>
            <div class="control-group"><span class="group-title">PingPongDelay</span><label for="pingpong-enable">Enable</label><input type="checkbox" id="pingpong-enable"><label for="pingpong-delay-time">Time</label><input type="range" id="pingpong-delay-time" min="0.01" max="1" value="0.35" step="0.01"><span id="pingpong-delay-time-display" class="value-display">0.35 s</span><label for="pingpong-feedback">Feedback</label><input type="range" id="pingpong-feedback" min="0" max="0.9" value="0.4" step="0.01"><span id="pingpong-feedback-display" class="value-display">0.4</span><label for="pingpong-wet">Wet</label><input type="range" id="pingpong-wet" min="0" max="1" value="0.0" step="0.01"><span id="pingpong-wet-display" class="value-display">0.0</span></div>
            <div class="control-group"><span class="group-title">Reverb</span><label for="reverb-enable">Enable</label><input type="checkbox" id="reverb-enable"><label for="reverb-decay">Decay</label><input type="range" id="reverb-decay" min="0.1" max="10" value="1.5" step="0.1"><span id="reverb-decay-display" class="value-display">1.5 s</span><label for="reverb-wet">Wet</label><input type="range" id="reverb-wet" min="0" max="1" value="0.0" step="0.01"><span id="reverb-wet-display" class="value-display">0.0</span></div>
        </div>

        <div class="keyboard-container">
            <div id="keyboard" class="keyboard select-none touch-manipulation"></div>
        </div>
        <div id="midi-status" class="text-sm mt-2">Initializing MIDI...</div>
        <p class="instructions">Computer Keyboard: Notes: 'A' row (white), 'Q' row (black). Octave: Z (down), X (up).</p>
    </div>
    <div id="audio-context-message-overlay" class="message-box-overlay"><div class="message-box-content"><p>Click "Start" to enable audio.</p><button id="start-audio-button">Start</button></div></div>

    <script>
        // --- Global Variables & Tone.js Objects ---
        let synth; 
        let startingOctave = 4; 
        let lfo1, lfo1ToDetuneGain, lfo1ToFilterFreqGain;
        let tremoloEffect, distortionEffect, bitCrusherEffect, ringModulatorEffect, chorusEffect, phaserEffect, delayEffect, pingPongDelayEffect, reverbEffect;
        let currentActiveSynthType = 'MonoSynth'; 
        let grainPlayerBuffer = null;
        let isGlobalMidiLearnActive = false;
        let paramKeyToLearn = null; 
        let midiMappings = {}; 


        // --- DOM Element Grabbing (Centralized) ---
        const dom = { /* ... (all previous dom elements PLUS ringmod and granular) ... */
            oscType: document.getElementById('osc-type'), pwmControls: document.getElementById('pwm-controls'), pwmSpeed: document.getElementById('pwm-speed'), pwmSpeedDisplay: document.getElementById('pwm-speed-display'), fmControls: document.getElementById('fm-controls'), fmHarmonicity: document.getElementById('fm-harmonicity'), fmHarmonicityDisplay: document.getElementById('fm-harmonicity-display'), fmModIndex: document.getElementById('fm-mod-index'), fmModIndexDisplay: document.getElementById('fm-mod-index-display'), 
            supersawControls: document.getElementById('supersaw-controls'), supersawCount: document.getElementById('supersaw-count'), supersawCountDisplay: document.getElementById('supersaw-count-display'), supersawSpread: document.getElementById('supersaw-spread'), supersawSpreadDisplay: document.getElementById('supersaw-spread-display'),
            resonantBodyControls: document.getElementById('resonantbody-controls'), resonantBodyHarmonicity: document.getElementById('resonantbody-harmonicity'), resonantBodyHarmonicityDisplay: document.getElementById('resonantbody-harmonicity-display'), resonantBodyModIndex: document.getElementById('resonantbody-mod-index'), resonantBodyModIndexDisplay: document.getElementById('resonantbody-mod-index-display'),
            formantVoiceControls: document.getElementById('formantvoice-controls'), formantVoiceHarmonicity: document.getElementById('formantvoice-harmonicity'), formantVoiceHarmonicityDisplay: document.getElementById('formantvoice-harmonicity-display'), formantVoiceModIndex: document.getElementById('formantvoice-mod-index'), formantVoiceModIndexDisplay: document.getElementById('formantvoice-mod-index-display'),
            granularControls: document.getElementById('granular-controls'), granularFileInput: document.getElementById('granular-file-input'), granularLoop: document.getElementById('granular-loop'), granularGrainSize: document.getElementById('granular-grain-size'), granularGrainSizeDisplay: document.getElementById('granular-grain-size-display'), granularOverlap: document.getElementById('granular-overlap'), granularOverlapDisplay: document.getElementById('granular-overlap-display'), granularDetune: document.getElementById('granular-detune'), granularDetuneDisplay: document.getElementById('granular-detune-display'), granularPlaybackRate: document.getElementById('granular-playback-rate'), granularPlaybackRateDisplay: document.getElementById('granular-playback-rate-display'),
            granularLoopStart: document.getElementById('granular-loop-start'), granularLoopStartDisplay: document.getElementById('granular-loop-start-display'),
            granularLoopEnd: document.getElementById('granular-loop-end'), granularLoopEndDisplay: document.getElementById('granular-loop-end-display'),
            granularReverse: document.getElementById('granular-reverse'),
            octaveDisplay: document.getElementById('octave-display'), 
            volume: document.getElementById('volume'), volumeDisplay: document.getElementById('volume-display'), 
            ampEnvAttack: document.getElementById('amp-env-attack'), ampEnvAttackDisplay: document.getElementById('amp-env-attack-display'), ampEnvDecay: document.getElementById('amp-env-decay'), ampEnvDecayDisplay: document.getElementById('amp-env-decay-display'), ampEnvSustain: document.getElementById('amp-env-sustain'), ampEnvSustainDisplay: document.getElementById('amp-env-sustain-display'), ampEnvRelease: document.getElementById('amp-env-release'), ampEnvReleaseDisplay: document.getElementById('amp-env-release-display'),
            filterType: document.getElementById('filter-type'), filterCutoff: document.getElementById('filter-cutoff'), filterCutoffDisplay: document.getElementById('filter-cutoff-display'), filterResonance: document.getElementById('filter-resonance'), filterResonanceDisplay: document.getElementById('filter-resonance-display'), 
            filterEnvAttack: document.getElementById('filter-env-attack'), filterEnvAttackDisplay: document.getElementById('filter-env-attack-display'), filterEnvDecay: document.getElementById('filter-env-decay'), filterEnvDecayDisplay: document.getElementById('filter-env-decay-display'), filterEnvSustain: document.getElementById('filter-env-sustain'), filterEnvSustainDisplay: document.getElementById('filter-env-sustain-display'), filterEnvRelease: document.getElementById('filter-env-release'), filterEnvReleaseDisplay: document.getElementById('filter-env-release-display'), filterEnvAmount: document.getElementById('filter-env-amount'), filterEnvAmountDisplay: document.getElementById('filter-env-amount-display'),
            lfo1Enable: document.getElementById('lfo1-enable'), lfo1Wave: document.getElementById('lfo1-wave'), lfo1Rate: document.getElementById('lfo1-rate'), lfo1RateDisplay: document.getElementById('lfo1-rate-display'), lfo1Depth: document.getElementById('lfo1-depth'), lfo1DepthDisplay: document.getElementById('lfo1-depth-display'), lfo1Destination: document.getElementById('lfo1-destination'),
            lfo1PulseWidthControls: document.getElementById('lfo1-pulse-width-controls'), lfo1PulseWidth: document.getElementById('lfo1-pulse-width'), lfo1PulseWidthDisplay: document.getElementById('lfo1-pulse-width-display'),
            lfo1PwmFreqControls: document.getElementById('lfo1-pwm-freq-controls'), lfo1PwmFreq: document.getElementById('lfo1-pwm-freq'), lfo1PwmFreqDisplay: document.getElementById('lfo1-pwm-freq-display'),
            distEnable: document.getElementById('dist-enable'), distAmount: document.getElementById('dist-amount'), distAmountDisplay: document.getElementById('dist-amount-display'), distWet: document.getElementById('dist-wet'), distWetDisplay: document.getElementById('dist-wet-display'), 
            crusherEnable: document.getElementById('crusher-enable'), crusherBits: document.getElementById('crusher-bits'), crusherBitsDisplay: document.getElementById('crusher-bits-display'), crusherWet: document.getElementById('crusher-wet'), crusherWetDisplay: document.getElementById('crusher-wet-display'),
            ringModEnable: document.getElementById('ringmod-enable'), ringModFrequency: document.getElementById('ringmod-frequency'), ringModFrequencyDisplay: document.getElementById('ringmod-frequency-display'), ringModWet: document.getElementById('ringmod-wet'), ringModWetDisplay: document.getElementById('ringmod-wet-display'),
            chorusEnable: document.getElementById('chorus-enable'), chorusRate: document.getElementById('chorus-rate'), chorusRateDisplay: document.getElementById('chorus-rate-display'), chorusDepth: document.getElementById('chorus-depth'), chorusDepthDisplay: document.getElementById('chorus-depth-display'), chorusFeedback: document.getElementById('chorus-feedback'), chorusFeedbackDisplay: document.getElementById('chorus-feedback-display'), chorusWet: document.getElementById('chorus-wet'), chorusWetDisplay: document.getElementById('chorus-wet-display'), 
            phaserEnable: document.getElementById('phaser-enable'), phaserFrequency: document.getElementById('phaser-frequency'), phaserFrequencyDisplay: document.getElementById('phaser-frequency-display'), phaserOctaves: document.getElementById('phaser-octaves'), phaserOctavesDisplay: document.getElementById('phaser-octaves-display'), phaserBaseFreq: document.getElementById('phaser-base-freq'), phaserBaseFreqDisplay: document.getElementById('phaser-base-freq-display'), phaserWet: document.getElementById('phaser-wet'), phaserWetDisplay: document.getElementById('phaser-wet-display'),
            delayEnable: document.getElementById('delay-enable'), delayTime: document.getElementById('delay-time'), delayTimeDisplay: document.getElementById('delay-time-display'), delayFeedback: document.getElementById('delay-feedback'), delayFeedbackDisplay: document.getElementById('delay-feedback-display'), delayWet: document.getElementById('delay-wet'), delayWetDisplay: document.getElementById('delay-wet-display'), 
            pingpongEnable: document.getElementById('pingpong-enable'), pingpongDelayTime: document.getElementById('pingpong-delay-time'), pingpongDelayTimeDisplay: document.getElementById('pingpong-delay-time-display'), pingpongFeedback: document.getElementById('pingpong-feedback'), pingpongFeedbackDisplay: document.getElementById('pingpong-feedback-display'), pingpongWet: document.getElementById('pingpong-wet'), pingpongWetDisplay: document.getElementById('pingpong-wet-display'),
            reverbEnable: document.getElementById('reverb-enable'), reverbDecay: document.getElementById('reverb-decay'), reverbDecayDisplay: document.getElementById('reverb-decay-display'), reverbWet: document.getElementById('reverb-wet'), reverbWetDisplay: document.getElementById('reverb-wet-display'), 
            keyboard: document.getElementById('keyboard'), audioContextMessageOverlay: document.getElementById('audio-context-message-overlay'), startAudioButton: document.getElementById('start-audio-button'), 
            midiStatus: document.getElementById('midi-status'), midiLearnButton: document.getElementById('midi-learn-button'), midiLearnStatus: document.getElementById('midi-learn-status')
        };
        
        for (const key in dom) { if (dom[key] === null) { console.error(`CRITICAL DOM ERROR: Element for dom.${key} not found!`); }}

        const paramDefinitions = { /* ... (Updated with granular and ringmod params) ... */
            'oscType': { elementId: 'osc-type', label: 'Osc Type', type: 'select', options: Array.from(dom.oscType.options).map(opt => opt.value), eventToDispatch: 'change' },
            'pwmSpeed': { elementId: 'pwm-speed', label: 'PWM Speed', type: 'range', min: 0.1, max: 20, eventToDispatch: 'input'},
            'fmHarmonicity': { elementId: 'fm-harmonicity', label: 'FM Harm', type: 'range', min: 0.1, max: 10, eventToDispatch: 'input'},
            'fmModIndex': { elementId: 'fm-mod-index', label: 'FM Index', type: 'range', min: 1, max: 50, eventToDispatch: 'input'},
            'supersawCount': { elementId: 'supersaw-count', label: 'Saw Count', type: 'range', min: 2, max: 10, eventToDispatch: 'input'},
            'supersawSpread': { elementId: 'supersaw-spread', label: 'Saw Spread', type: 'range', min: 0, max: 100, eventToDispatch: 'input'},
            'resonantBodyHarmonicity': { elementId: 'resonantbody-harmonicity', label: 'Reso Harm', type: 'range', min: 0.1, max: 20, eventToDispatch: 'input'},
            'resonantBodyModIndex': { elementId: 'resonantbody-mod-index', label: 'Reso Index', type: 'range', min: 1, max: 100, eventToDispatch: 'input'},
            'formantVoiceHarmonicity': { elementId: 'formantvoice-harmonicity', label: 'Formant Harm', type: 'range', min: 0.1, max: 5, eventToDispatch: 'input'},
            'formantVoiceModIndex': { elementId: 'formantvoice-mod-index', label: 'Formant Index', type: 'range', min: 1, max: 30, eventToDispatch: 'input'},
            'granularLoop': { elementId: 'granular-loop', label: 'Granular Loop', type: 'checkbox', eventToDispatch: 'change'},
            'granularLoopStart': { elementId: 'granular-loop-start', label: 'Granular Loop Start', type: 'range', min: 0, max: 1, eventToDispatch: 'input'},
            'granularLoopEnd': { elementId: 'granular-loop-end', label: 'Granular Loop End', type: 'range', min: 0, max: 1, eventToDispatch: 'input'},
            'granularReverse': { elementId: 'granular-reverse', label: 'Granular Reverse', type: 'checkbox', eventToDispatch: 'change'},
            'granularGrainSize': { elementId: 'granular-grain-size', label: 'Grain Size', type: 'range', min: 0.01, max: 0.5, eventToDispatch: 'input'},
            'granularOverlap': { elementId: 'granular-overlap', label: 'Grain Overlap', type: 'range', min: -0.1, max: 0.4, eventToDispatch: 'input'},
            'granularDetune': { elementId: 'granular-detune', label: 'Grain Detune', type: 'range', min:0, max:1200, eventToDispatch: 'input'},
            'granularPlaybackRate': { elementId: 'granular-playback-rate', label: 'Grain Playback Rate', type: 'range', min:0.1, max:4, eventToDispatch: 'input'},
            'masterVolume': { elementId: 'volume', label: 'Master Volume', type: 'range', min: -40, max: 0, eventToDispatch: 'input' },
            'ampEnvAttack': { elementId: 'amp-env-attack', label: 'Amp Attack', type: 'range', min: 0.005, max: 2, eventToDispatch: 'input' },
            'ampEnvDecay': { elementId: 'amp-env-decay', label: 'Amp Decay', type: 'range', min: 0.01, max: 2, eventToDispatch: 'input' },
            'ampEnvSustain': { elementId: 'amp-env-sustain', label: 'Amp Sustain', type: 'range', min: 0, max: 1, eventToDispatch: 'input' },
            'ampEnvRelease': { elementId: 'amp-env-release', label: 'Amp Release', type: 'range', min: 0.01, max: 5, eventToDispatch: 'input' },
            'filterType': { elementId: 'filter-type', label: 'Filter Type', type: 'select', options: Array.from(dom.filterType.options).map(opt => opt.value), eventToDispatch: 'change' },
            'filterCutoff': { elementId: 'filter-cutoff', label: 'Filter Cutoff', type: 'range', min: 20, max: 20000, eventToDispatch: 'input' },
            'filterResonance': { elementId: 'filter-resonance', label: 'Filter Reso', type: 'range', min: 0.1, max: 30, eventToDispatch: 'input' },
            'filterEnvAttack': { elementId: 'filter-env-attack', label: 'Filt Env Attack', type: 'range', min: 0.005, max: 2, eventToDispatch: 'input' },
            'filterEnvDecay': { elementId: 'filter-env-decay', label: 'Filt Env Decay', type: 'range', min: 0.01, max: 2, eventToDispatch: 'input' },
            'filterEnvSustain': { elementId: 'filter-env-sustain', label: 'Filt Env Sustain', type: 'range', min: 0, max: 1, eventToDispatch: 'input' },
            'filterEnvRelease': { elementId: 'filter-env-release', label: 'Filt Env Release', type: 'range', min: 0.01, max: 5, eventToDispatch: 'input' },
            'filterEnvAmount': { elementId: 'filter-env-amount', label: 'Filt Env Amt', type: 'range', min: -7, max: 7, eventToDispatch: 'input' },
            'lfo1Enable': { elementId: 'lfo1-enable', label: 'LFO1 Enable', type: 'checkbox', eventToDispatch: 'change' },
            'lfo1Wave': { elementId: 'lfo1-wave', label: 'LFO1 Wave', type: 'select', options: Array.from(dom.lfo1Wave.options).map(opt => opt.value), eventToDispatch: 'change' },
            'lfo1PulseWidth': { elementId: 'lfo1-pulse-width', label: 'LFO1 Pulse Width', type: 'range', min:0.01, max:0.99, eventToDispatch: 'input'},
            'lfo1PwmFreq': { elementId: 'lfo1-pwm-freq', label: 'LFO1 PWM Freq', type: 'range', min:0.1, max:20, eventToDispatch: 'input'},
            'lfo1Rate': { elementId: 'lfo1-rate', label: 'LFO1 Rate', type: 'range', min: 0.1, max: 30, eventToDispatch: 'input' },
            'lfo1Depth': { elementId: 'lfo1-depth', label: 'LFO1 Depth', type: 'range', min: 0, max: 1, eventToDispatch: 'input' },
            'lfo1Destination': { elementId: 'lfo1-destination', label: 'LFO1 Dest', type: 'select', options: Array.from(dom.lfo1Destination.options).map(opt => opt.value), eventToDispatch: 'change' },
            'distEnable': { elementId: 'dist-enable', label: 'Distortion Enable', type: 'checkbox', eventToDispatch: 'change'}, 'distAmount': { elementId: 'dist-amount', label: 'Distortion Amt', type: 'range', min:0, max:1, eventToDispatch: 'input'}, 'distWet': { elementId: 'dist-wet', label: 'Distortion Wet', type: 'range', min:0, max:1, eventToDispatch: 'input'},
            'crusherEnable': { elementId: 'crusher-enable', label: 'BitCrush Enable', type: 'checkbox', eventToDispatch: 'change'}, 'crusherBits': { elementId: 'crusher-bits', label: 'BitCrush Bits', type: 'range', min:1, max:16, eventToDispatch: 'input'}, 'crusherWet': { elementId: 'crusher-wet', label: 'BitCrush Wet', type: 'range', min:0, max:1, eventToDispatch: 'input'},
            'ringModEnable': { elementId: 'ringmod-enable', label: 'RingMod Enable', type: 'checkbox', eventToDispatch: 'change'}, 'ringModFrequency': { elementId: 'ringmod-frequency', label: 'RingMod Freq', type: 'range', min:1, max:2000, eventToDispatch: 'input'}, 'ringModWet': { elementId: 'ringmod-wet', label: 'RingMod Wet', type: 'range', min:0, max:1, eventToDispatch: 'input'},
            'chorusEnable': { elementId: 'chorus-enable', label: 'Chorus Enable', type: 'checkbox', eventToDispatch: 'change'}, 'chorusRate': { elementId: 'chorus-rate', label: 'Chorus Rate', type: 'range', min:0.1, max:8, eventToDispatch: 'input'}, 'chorusDepth': { elementId: 'chorus-depth', label: 'Chorus Depth', type: 'range', min:0, max:1, eventToDispatch: 'input'}, 'chorusFeedback': { elementId: 'chorus-feedback', label: 'Chorus Fbk', type: 'range', min:0, max:0.9, eventToDispatch: 'input'}, 'chorusWet': { elementId: 'chorus-wet', label: 'Chorus Wet', type: 'range', min:0, max:1, eventToDispatch: 'input'},
            'phaserEnable': { elementId: 'phaser-enable', label: 'Phaser Enable', type: 'checkbox', eventToDispatch: 'change'}, 'phaserFrequency': { elementId: 'phaser-frequency', label: 'Phaser Freq', type: 'range', min:0.1, max:10, eventToDispatch: 'input'}, 'phaserOctaves': { elementId: 'phaser-octaves', label: 'Phaser Octs', type: 'range', min:1, max:8, eventToDispatch: 'input'}, 'phaserBaseFreq': { elementId: 'phaser-base-freq', label: 'Phaser Base', type: 'range', min:100, max:1500, eventToDispatch: 'input'}, 'phaserWet': { elementId: 'phaser-wet', label: 'Phaser Wet', type: 'range', min:0, max:1, eventToDispatch: 'input'},
            'delayEnable': { elementId: 'delay-enable', label: 'Delay Enable', type: 'checkbox', eventToDispatch: 'change'}, 'delayTime': { elementId: 'delay-time', label: 'Delay Time', type: 'range', min:0.01, max:1, eventToDispatch: 'input'}, 'delayFeedback': { elementId: 'delay-feedback', label: 'Delay Fbk', type: 'range', min:0, max:0.9, eventToDispatch: 'input'}, 'delayWet': { elementId: 'delay-wet', label: 'Delay Wet', type: 'range', min:0, max:1, eventToDispatch: 'input'},
            'pingpongEnable': { elementId: 'pingpong-enable', label: 'PingPong Enable', type: 'checkbox', eventToDispatch: 'change'}, 'pingpongDelayTime': { elementId: 'pingpong-delay-time', label: 'PP Delay Time', type: 'range', min:0.01, max:1, eventToDispatch: 'input'}, 'pingpongFeedback': { elementId: 'pingpong-feedback', label: 'PP Delay Fbk', type: 'range', min:0, max:0.9, eventToDispatch: 'input'}, 'pingpongWet': { elementId: 'pingpong-wet', label: 'PP Delay Wet', type: 'range', min:0, max:1, eventToDispatch: 'input'},
            'reverbEnable': { elementId: 'reverb-enable', label: 'Reverb Enable', type: 'checkbox', eventToDispatch: 'change'}, 'reverbDecay': { elementId: 'reverb-decay', label: 'Reverb Decay', type: 'range', min:0.1, max:10, eventToDispatch: 'input'}, 'reverbWet': { elementId: 'reverb-wet', label: 'Reverb Wet', type: 'range', min:0, max:1, eventToDispatch: 'input'},
        };
        
        const notesLayout = [ { name: 'C', freqName: 'C', type: 'white' }, { name: 'C#', freqName: 'C#', type: 'black' },{ name: 'D', freqName: 'D', type: 'white' }, { name: 'D#', freqName: 'D#', type: 'black' },{ name: 'E', freqName: 'E', type: 'white' }, { name: 'F', freqName: 'F', type: 'white' },{ name: 'F#', freqName: 'F#', type: 'black' }, { name: 'G', freqName: 'G', type: 'white' },{ name: 'G#', freqName: 'G#', type: 'black' }, { name: 'A', freqName: 'A', type: 'white' },{ name: 'A#', freqName: 'A#', type: 'black' }, { name: 'B', freqName: 'B', type: 'white' } ];
        const noteNamesSharp = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const pressedComputerKeys = new Set();
        const computerKeyNoteMapping = { 'a': 'C', 's': 'D', 'd': 'E', 'f': 'F', 'g': 'G', 'h': 'A', 'j': 'B', 'w': 'C#', 'e': 'D#', 't': 'F#', 'y': 'G#', 'u': 'A#'};
        let midiAccess = null;

        function showMessage(overlayElem, message, buttonText, callback) { /* ... (same) ... */ console.log("Showing message:", message); const p = overlayElem.querySelector('p'); const btn = overlayElem.querySelector('button'); if (p) p.textContent = message; if (btn) btn.textContent = buttonText; overlayElem.classList.add('visible'); return new Promise((resolve) => { const clickHandler = async () => { overlayElem.classList.remove('visible'); btn.removeEventListener('click', clickHandler); if (callback) await callback(); resolve(); }; btn.addEventListener('click', clickHandler); }); }
        function updateSliderDisplay(slider, displayElement, unit = '', decimals = 1) { /* ... (same) ... */ if (!slider || !displayElement) { console.warn("updateSliderDisplay: Missing slider or displayElement for unit:", unit); return; } const value = parseFloat(slider.value).toFixed(decimals); displayElement.textContent = `${value} ${unit}`; }

        async function initializeAudio() {
            console.log("AUDIO_INIT: Starting. Tone.context.state:", Tone.context.state);
            if (Tone.context.state !== 'running') {
                try { await Tone.start(); console.log("AUDIO_INIT: Tone.start() OK. State:", Tone.context.state); }
                catch (error) { console.error("AUDIO_INIT_ERROR: Tone.start() failed:", error); showMessage(dom.audioContextMessageOverlay, "Error initializing audio.", "Close", () => {}); return false; }
            }
            if (!tremoloEffect) { 
                try {
                    console.log("AUDIO_INIT: Creating ALL effect nodes...");
                    lfo1ToDetuneGain = new Tone.Multiply(0); 
                    lfo1ToFilterFreqGain = new Tone.Multiply(0);
                    lfo1 = new Tone.LFO({ frequency: parseFloat(dom.lfo1Rate.value), type: dom.lfo1Wave.value, min: -1, max: 1 });
                    
                    tremoloEffect = new Tone.Tremolo({ frequency: parseFloat(dom.lfo1Rate.value), type: dom.lfo1Wave.value, depth: 0, spread: 0 });
                    distortionEffect = new Tone.Distortion(parseFloat(dom.distAmount.value));
                    bitCrusherEffect = new Tone.BitCrusher(parseInt(dom.crusherBits.value));
                    ringModulatorEffect = new Tone.FrequencyShifter(parseFloat(dom.ringModFrequency.value)); 
                    // For FrequencyShifter to act as a ring modulator, wet level controls mix. The core "depth" of shift is always there.
                    chorusEffect = new Tone.Chorus({ frequency: parseFloat(dom.chorusRate.value), depth: parseFloat(dom.chorusDepth.value), feedback: parseFloat(dom.chorusFeedback.value), delayTime: 3.5, type: "sine" });
                    phaserEffect = new Tone.Phaser({ frequency: parseFloat(dom.phaserFrequency.value), octaves: parseFloat(dom.phaserOctaves.value), baseFrequency: parseFloat(dom.phaserBaseFreq.value) });
                    delayEffect = new Tone.FeedbackDelay({ delayTime: parseFloat(dom.delayTime.value), feedback: parseFloat(dom.delayFeedback.value) });
                    pingPongDelayEffect = new Tone.PingPongDelay({ delayTime: parseFloat(dom.pingpongDelayTime.value), feedback: parseFloat(dom.pingpongFeedback.value) });
                    reverbEffect = new Tone.Reverb({ decay: parseFloat(dom.reverbDecay.value), preDelay: 0.01 });
                    console.log("AUDIO_INIT: All effect nodes created.");

                    distortionEffect.wet.value = dom.distEnable.checked ? parseFloat(dom.distWet.value) : 0; 
                    bitCrusherEffect.wet.value = dom.crusherEnable.checked ? parseFloat(dom.crusherWet.value) : 0; 
                    ringModulatorEffect.wet.value = dom.ringModEnable.checked ? parseFloat(dom.ringModWet.value) : 0;
                    chorusEffect.wet.value = dom.chorusEnable.checked ? parseFloat(dom.chorusWet.value) : 0; 
                    phaserEffect.wet.value = dom.phaserEnable.checked ? parseFloat(dom.phaserWet.value) : 0; 
                    delayEffect.wet.value = dom.delayEnable.checked ? parseFloat(dom.delayWet.value) : 0; 
                    pingPongDelayEffect.wet.value = dom.pingpongEnable.checked ? parseFloat(dom.pingpongWet.value) : 0; 
                    reverbEffect.wet.value = dom.reverbEnable.checked ? parseFloat(dom.reverbWet.value) : 0;

                } catch (error) { console.error("AUDIO_INIT_ERROR: Creating effect nodes failed:", error); return false; }
            }
            
            updateOscillatorType(); 
            
            // applyAudioChain and updateLFO1Connections are called within updateOscillatorType if synth is (re)created.
            // If synth already existed, they are called from there too.

            console.log(`AUDIO_INIT: PRE-TEST_SOUND. Tone.context.state: ${Tone.context.state}. Synth exists: ${!!synth}. Synth type: ${currentActiveSynthType}`);
            if (synth && Tone.context.state === 'running' && currentActiveSynthType !== 'GrainPlayer') { 
                synth.triggerAttackRelease("C4", "8n", Tone.now() + 0.1); 
                console.log("AUDIO_INIT: TEST SOUND (C4) triggered for PolySynth.");
            } else { console.warn("AUDIO_INIT: TEST SOUND NOT TRIGGERED (or Granular mode active or synth not ready)."); }
            
            await initializeMIDI();
            loadMidiMappings();
            
            console.log("AUDIO_INIT: Initialization finished.");
            return true;
        }
        
        function updateOscillatorType() {
            if (!Tone.context || Tone.context.state !== 'running') { console.warn("UPDATE_OSC_TYPE_WARN: AudioContext not running."); return; }
            const newSelectedOscType = dom.oscType.value;
            let newActiveSynthType = (newSelectedOscType === 'granular') ? 'GrainPlayer' : 'MonoSynth';
            console.log("UPDATE_OSC_TYPE: Selected type:", newSelectedOscType, "Required synth type:", newActiveSynthType);

            dom.pwmControls.classList.add('hidden'); dom.fmControls.classList.add('hidden');
            dom.supersawControls.classList.add('hidden'); 
            dom.resonantBodyControls.classList.add('hidden'); 
            dom.formantVoiceControls.classList.add('hidden');
            dom.granularControls.classList.add('hidden');


            switch (newSelectedOscType) {
                case 'pwm': dom.pwmControls.classList.remove('hidden'); break;
                case 'fmsine': dom.fmControls.classList.remove('hidden'); break;
                case 'supersaw': dom.supersawControls.classList.remove('hidden'); break; 
                case 'resonantbody': dom.resonantBodyControls.classList.remove('hidden'); break;
                case 'formantvoice': dom.formantVoiceControls.classList.remove('hidden'); break;
                case 'granular': dom.granularControls.classList.remove('hidden'); break;
            }
            
            if (currentActiveSynthType !== newActiveSynthType || !synth) {
                console.log("UPDATE_OSC_TYPE: Synth type change needed or first init. Old active type:", currentActiveSynthType, "New active type:", newActiveSynthType);
                const oldVolume = synth && typeof synth.volume !== 'undefined' && typeof synth.volume.value !== 'undefined' ? synth.volume.value : parseFloat(dom.volume.value); 

                if (synth) {
                    console.log("UPDATE_OSC_TYPE: Disposing old synth.");
                    if (typeof synth.releaseAll === 'function') synth.releaseAll();
                    synth.disconnect(); 
                    synth.dispose(); 
                    synth = null;
                }
                if(lfo1ToDetuneGain) { lfo1ToDetuneGain.dispose(); lfo1ToDetuneGain = new Tone.Multiply(0); }
                if(lfo1ToFilterFreqGain) { lfo1ToFilterFreqGain.dispose(); lfo1ToFilterFreqGain = new Tone.Multiply(0); }


                if (newActiveSynthType === 'GrainPlayer') {
                    // Create an empty GrainPlayer first. Buffer will be assigned by file loader or if already loaded.
                    synth = new Tone.GrainPlayer();
                    console.log("UPDATE_OSC_TYPE: New GrainPlayer instance created (buffer may not be loaded yet).");
                    if (grainPlayerBuffer && grainPlayerBuffer.loaded) {
                        synth.buffer = grainPlayerBuffer;
                        console.log("UPDATE_OSC_TYPE: Existing buffer assigned to new GrainPlayer.");
                    } else {
                        dom.midiLearnStatus.textContent = "Load WAV for Granular";
                        console.warn("UPDATE_OSC_TYPE: GrainPlayer created, but needs a buffer. Load a WAV file.");
                    }
                } else { 
                    currentActiveSynthType = 'MonoSynth'; 
                    synth = new Tone.PolySynth(Tone.MonoSynth); 
                    console.log("UPDATE_OSC_TYPE: New PolySynth(MonoSynth) created.");
                }
                
                if (synth) { // Check if synth (GrainPlayer or PolySynth) was successfully created
                    synth.volume.value = oldVolume;
                }
            }
            
            if (synth) { 
                 applyCurrentOscillatorSpecificSettings(newSelectedOscType);
                 applyAudioChain(); 
                 updateLFO1Connections();
            } else if (newActiveSynthType === 'GrainPlayer' && !grainPlayerBuffer) {
                // If granular is selected and no buffer, synth will be null.
                // We still might want to apply the audio chain with synth as null to disconnect effects.
                applyAudioChain(); 
            }
        }


        function applyCurrentOscillatorSpecificSettings(selectedOscType) {
            if (!synth) { console.warn("APPLY_OSC_SETTINGS_WARN: Synth not ready for type:", selectedOscType); return; }
            console.log("APPLY_OSC_SETTINGS: Applying for type:", selectedOscType, "to current synth type:", currentActiveSynthType);

            if (currentActiveSynthType === 'MonoSynth') { 
                let settingsForSynthSet = {
                    volume: parseFloat(dom.volume.value), 
                    envelope: { 
                        attack: parseFloat(dom.ampEnvAttack.value),
                        decay: parseFloat(dom.ampEnvDecay.value),
                        sustain: parseFloat(dom.ampEnvSustain.value),
                        release: parseFloat(dom.ampEnvRelease.value),
                    }
                };
                let filterTypeString = "lowpass"; let filterRolloff = -24; 
                const selectedUIFilterType = dom.filterType.value;
                if (selectedUIFilterType !== "none") {
                    switch(selectedUIFilterType) { /* ... (filter type switch) ... */ case 'moog': filterTypeString = 'lowpass'; filterRolloff = -24; break; case 'ms20lp': filterTypeString = 'lowpass'; filterRolloff = -12; break; case 'ms20hp': filterTypeString = 'highpass'; filterRolloff = -12; break; case 'bandpass12': filterTypeString = 'bandpass'; filterRolloff = -12; break; case 'bandpass24': filterTypeString = 'bandpass'; filterRolloff = -24; break; case 'notch12': filterTypeString = 'notch'; filterRolloff = -12; break; case 'notch24': filterTypeString = 'notch'; filterRolloff = -24; break; case 'allpass': filterTypeString = 'allpass'; filterRolloff = -12; break;}
                    settingsForSynthSet.filter = { type: filterTypeString, Q: parseFloat(dom.filterResonance.value), rolloff: filterRolloff };
                    settingsForSynthSet.filterEnvelope = { attack: parseFloat(dom.filterEnvAttack.value), decay: parseFloat(dom.filterEnvDecay.value), sustain: parseFloat(dom.filterEnvSustain.value), release: parseFloat(dom.filterEnvRelease.value), baseFrequency: parseFloat(dom.filterCutoff.value), octaves: parseFloat(dom.filterEnvAmount.value), exponent: 2 };
                } else { settingsForSynthSet.filter = { type: 'lowpass', Q: 0.1, frequency: 20000, rolloff: -12 }; settingsForSynthSet.filterEnvelope = { attack:0.005, decay:0.01, sustain:1, release:0.01, baseFrequency: 20000, octaves: 0}; }

                let monoSynthOscSettings = {};
                switch (selectedOscType) { /* ... (other osc settings switch) ... */ case 'sine': case 'square': case 'triangle': case 'sawtooth': monoSynthOscSettings = { type: selectedOscType }; break; case 'pwm': monoSynthOscSettings = { type: 'pwm', modulationFrequency: parseFloat(dom.pwmSpeed.value) }; break; case 'fmsine': monoSynthOscSettings = { type: 'fmsine', harmonicity: parseFloat(dom.fmHarmonicity.value), modulationIndex: parseFloat(dom.fmModIndex.value), modulationType: 'sine' }; break; case 'amsine': monoSynthOscSettings = { type: 'amsine', harmonicity: 1, modulationType: 'square' }; break; case 'supersaw': monoSynthOscSettings = { type: 'fatsawtooth', count: parseInt(dom.supersawCount.value), spread: parseFloat(dom.supersawSpread.value) }; break; case 'resonantbody': monoSynthOscSettings = { type: 'fmsine', harmonicity: parseFloat(dom.resonantBodyHarmonicity.value), modulationIndex: parseFloat(dom.resonantBodyModIndex.value), modulationType: 'sine' }; break; case 'formantvoice': monoSynthOscSettings = { type: 'fmsine', harmonicity: parseFloat(dom.formantVoiceHarmonicity.value), modulationIndex: parseFloat(dom.formantVoiceModIndex.value), modulationType: 'triangle' }; break; default: monoSynthOscSettings = { type: 'sine' }; }
                settingsForSynthSet.oscillator = monoSynthOscSettings;
                try { synth.set(settingsForSynthSet); console.log("APPLY_OSC_SETTINGS: Applied to PolySynth (MonoSynth voices):", settingsForSynthSet); } 
                catch(e) { console.error("APPLY_OSC_SETTINGS_ERROR: Failed to set options for MonoSynth based PolySynth", selectedOscType, settingsForSynthSet, e); }
            } else if (currentActiveSynthType === 'GrainPlayer' && selectedOscType === 'granular' && synth && synth.loaded) {
                synth.loop = dom.granularLoop.checked;
                synth.loopStart = parseFloat(dom.granularLoopStart.value);
                synth.loopEnd = parseFloat(dom.granularLoopEnd.value);
                synth.reverse = dom.granularReverse.checked;
                synth.grainSize = parseFloat(dom.granularGrainSize.value);
                synth.overlap = parseFloat(dom.granularOverlap.value);
                synth.detune = parseFloat(dom.granularDetune.value);
                synth.playbackRate = parseFloat(dom.granularPlaybackRate.value);
                synth.volume.value = parseFloat(dom.volume.value); // Also ensure GrainPlayer volume is set
                console.log("APPLY_OSC_SETTINGS: Applied to GrainPlayer:", {loop: synth.loop, grainSize: synth.grainSize, overlap: synth.overlap, detune:synth.detune, playbackRate: synth.playbackRate});
            } else if (currentActiveSynthType === 'GrainPlayer' && selectedOscType === 'granular' && (!synth || !synth.loaded)) {
                console.log("APPLY_OSC_SETTINGS: GrainPlayer selected but buffer not loaded or synth not ready. Waiting for file.");
            }
        }
        
        function applyAudioChain() { 
            const allEffectNodes = [tremoloEffect, distortionEffect, bitCrusherEffect, ringModulatorEffect, chorusEffect, phaserEffect, delayEffect, pingPongDelayEffect, reverbEffect];
            allEffectNodes.forEach(node => { if(node) try { node.disconnect(); } catch(e){} }); // Disconnect all effects
            if (!synth) { console.warn("APPLY_CHAIN_WARN: Synth object is null, cannot build audio chain."); return; } 

            console.log("APPLY_CHAIN: Rebuilding audio chain..."); 
            
            let currentNode = synth; 
            currentNode.connect(tremoloEffect); currentNode = tremoloEffect; 
            if (dom.distEnable.checked && parseFloat(dom.distWet.value) > 0) { distortionEffect.wet.value = parseFloat(dom.distWet.value); currentNode.connect(distortionEffect); currentNode = distortionEffect; } else { distortionEffect.wet.value = 0; } 
            if (dom.crusherEnable.checked && parseFloat(dom.crusherWet.value) > 0) { bitCrusherEffect.wet.value = parseFloat(dom.crusherWet.value); currentNode.connect(bitCrusherEffect); currentNode = bitCrusherEffect; } else { bitCrusherEffect.wet.value = 0; }  
            if (dom.ringModEnable.checked && parseFloat(dom.ringModWet.value) > 0) { ringModulatorEffect.wet.value = parseFloat(dom.ringModWet.value); currentNode.connect(ringModulatorEffect); currentNode = ringModulatorEffect; } else { ringModulatorEffect.wet.value = 0;}
            // Filter is per-voice for PolySynth(MonoSynth), or not applicable to GrainPlayer in this master effects chain.
            if (dom.chorusEnable.checked && parseFloat(dom.chorusWet.value) > 0) { chorusEffect.wet.value = parseFloat(dom.chorusWet.value); currentNode.connect(chorusEffect); currentNode = chorusEffect; } else { chorusEffect.wet.value = 0; } 
            if (dom.phaserEnable.checked && parseFloat(dom.phaserWet.value) > 0) { phaserEffect.wet.value = parseFloat(dom.phaserWet.value); currentNode.connect(phaserEffect); currentNode = phaserEffect; } else { phaserEffect.wet.value = 0; } 
            if (dom.delayEnable.checked && parseFloat(dom.delayWet.value) > 0) { delayEffect.wet.value = parseFloat(dom.delayWet.value); currentNode.connect(delayEffect); currentNode = delayEffect; } else { delayEffect.wet.value = 0; } 
            if (dom.pingpongEnable.checked && parseFloat(dom.pingpongWet.value) > 0) { pingPongDelayEffect.wet.value = parseFloat(dom.pingpongWet.value); currentNode.connect(pingPongDelayEffect); currentNode = pingPongDelayEffect; } else { pingPongDelayEffect.wet.value = 0; } 
            if (dom.reverbEnable.checked && parseFloat(dom.reverbWet.value) > 0) { reverbEffect.wet.value = parseFloat(dom.reverbWet.value); currentNode.connect(reverbEffect); currentNode = reverbEffect; } else { reverbEffect.wet.value = 0; } 
            currentNode.toDestination(); 
            console.log("APPLY_CHAIN: Finalized. Last node:", currentNode.name || currentNode.constructor.name); 
        }
        function updateLFO1Connections() { /* ... (same - ensure robust checks for synth.get().filterEnvelope) ... */ if (!lfo1 || !synth || !tremoloEffect || !lfo1ToDetuneGain || !lfo1ToFilterFreqGain ) { console.warn("LFO1_CONN_WARN: Node(s) not ready."); return; } const isEnabled = dom.lfo1Enable.checked; const rate = parseFloat(dom.lfo1Rate.value); const depth = parseFloat(dom.lfo1Depth.value); const lfoWave = dom.lfo1Wave.value; const destination = dom.lfo1Destination.value; lfo1.frequency.value = rate; lfo1.type = lfoWave; dom.lfo1PulseWidthControls.classList.toggle('hidden', lfoWave !== 'pulse'); dom.lfo1PwmFreqControls.classList.toggle('hidden', lfoWave !== 'pwm'); if (lfoWave === 'pulse') { lfo1.width.value = parseFloat(dom.lfo1PulseWidth.value); } else if (lfoWave === 'pwm') { lfo1.modulationFrequency.value = parseFloat(dom.lfo1PwmFreq.value); } try { lfo1.disconnect(lfo1ToDetuneGain); if(currentActiveSynthType === 'MonoSynth' && synth.detune) lfo1ToDetuneGain.disconnect(synth.detune); } catch (e) {} try { lfo1.disconnect(lfo1ToFilterFreqGain); if (currentActiveSynthType === 'MonoSynth' && synth.get().filterEnvelope && synth.get().filterEnvelope.baseFrequency) lfo1ToFilterFreqGain.disconnect(synth.filterEnvelope.baseFrequency); } catch (e) {} tremoloEffect.depth.value = 0; tremoloEffect.wet.value = 0; if (isEnabled) { if (lfo1.state !== "started") lfo1.start(); switch (destination) { case 'pitch': if(currentActiveSynthType === 'MonoSynth' && synth.detune) {lfo1ToDetuneGain.factor.value = depth * 200; lfo1.connect(lfo1ToDetuneGain); lfo1ToDetuneGain.connect(synth.detune);} else { console.log("LFO to Pitch: Not applicable for current synth type.");} break; case 'filterCutoff': if (currentActiveSynthType === 'MonoSynth' && dom.filterType.value !== "none" && synth.get().filterEnvelope && synth.get().filterEnvelope.baseFrequency) { lfo1ToFilterFreqGain.factor.value = depth * 5000; lfo1.connect(lfo1ToFilterFreqGain); lfo1ToFilterFreqGain.connect(synth.filterEnvelope.baseFrequency); } else { console.log("LFO to Filter: Not applicable or no filter envelope on current synth.");} break; case 'amplitude': tremoloEffect.frequency.value = rate; let tremoloLfoType = (lfoWave === 'pulse' || lfoWave === 'pwm') ? 'square' : lfoWave; tremoloEffect.type = tremoloLfoType; tremoloEffect.depth.value = depth; tremoloEffect.wet.value = 1; break; default: break;} } else { if (lfo1.state === "started") lfo1.stop(); }}
        function createOnScreenKeyboard() { /* ... (same) ... */ dom.keyboard.innerHTML = ''; let currentWhiteKeyOffset = 0; const whiteKeyWidth = 38; const blackKeyWidth = 26; for (let oct = 0; oct < 2; oct++) { notesLayout.forEach((noteLayout) => { const keyElement = document.createElement('div'); keyElement.classList.add('key'); const currentKeyOctave = startingOctave + oct; keyElement.dataset.fullNote = `${noteLayout.freqName}${currentKeyOctave}`; keyElement.textContent = noteLayout.name; if (noteLayout.type === 'white') { keyElement.classList.add('white-key'); keyElement.style.left = `${currentWhiteKeyOffset}px`; dom.keyboard.appendChild(keyElement); currentWhiteKeyOffset += whiteKeyWidth; } else { keyElement.classList.add('black-key'); keyElement.style.left = `${currentWhiteKeyOffset - (whiteKeyWidth/2)}px`; dom.keyboard.appendChild(keyElement); } const playNoteHandler = async (event) => { event.preventDefault(); const noteToPlay = keyElement.dataset.fullNote; if (Tone.context.state !== 'running' || !synth) { await showMessage(dom.audioContextMessageOverlay, "Audio not active.", "Start", async () => { if(await initializeAudio()) playNote(noteToPlay); }); return; } playNote(noteToPlay); }; const releaseNoteHandler = (event) => { event.preventDefault(); const noteToRelease = keyElement.dataset.fullNote; releaseNote(noteToRelease); }; keyElement.addEventListener('mousedown', playNoteHandler); keyElement.addEventListener('touchstart', playNoteHandler, { passive: false }); keyElement.addEventListener('mouseup', releaseNoteHandler); keyElement.addEventListener('touchend', releaseNoteHandler, { passive: false }); keyElement.addEventListener('mouseleave', (e) => { if (keyElement.classList.contains('active')) { const noteToRelease = keyElement.dataset.fullNote; releaseNote(noteToRelease);}}); }); } }
        function updateKeyVisualState(fullNoteName, isActive) { /* ... (same) ... */ const keys = dom.keyboard.querySelectorAll('.key'); keys.forEach(key => { if (key.dataset.fullNote === fullNoteName) { key.classList.toggle('active', isActive); } }); }
        function playNote(fullNoteName, velocity = 0.75) { /* ... (same) ... */ if (!synth || Tone.context.state !== 'running') { console.warn("PlayNote: Synth not ready or audio context not running."); return; } try { if (currentActiveSynthType === 'GrainPlayer') { if (synth.loaded) { synth.volume.value = parseFloat(dom.volume.value); if (synth.loop && synth.buffer) { const loopStartSec = synth.loopStart * synth.buffer.duration; const loopEndSec = synth.loopEnd * synth.buffer.duration; let duration = loopEndSec > loopStartSec ? loopEndSec - loopStartSec : synth.buffer.duration - loopStartSec + loopEndSec; if (duration <= 0) duration = synth.buffer.duration - loopStartSec; if (duration > 0) synth.start(Tone.now(), loopStartSec, duration); else console.warn("GrainPlayer: Loop duration invalid.");} else if (synth.buffer) { synth.start(Tone.now(), 0, synth.buffer.duration); } else { console.warn("PlayNote (GrainPlayer): Buffer not available."); return; } } else { console.warn("PlayNote (GrainPlayer): Buffer not loaded. Cannot play."); return; } } else if (currentActiveSynthType === 'MonoSynth') {synth.triggerAttack(fullNoteName, Tone.now(), velocity); } updateKeyVisualState(fullNoteName, true); } catch (error) { console.error(`Error playing ${fullNoteName}:`, error); } }
        function releaseNote(fullNoteName) { /* ... (same) ... */ if (!synth) return; try { if (currentActiveSynthType === 'GrainPlayer' && synth.loaded) { synth.stop(Tone.now() + 0.05); } else if (currentActiveSynthType === 'MonoSynth') {synth.triggerRelease(fullNoteName, Tone.now() + 0.05); } updateKeyVisualState(fullNoteName, false); } catch (error) { console.error(`Error releasing ${fullNoteName}:`, error); } }
        window.addEventListener('keydown', (event) => { if (!synth || event.repeat || event.metaKey || event.ctrlKey || event.altKey || document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') return; const key = event.key.toLowerCase(); if (computerKeyNoteMapping[key] && !pressedComputerKeys.has(key)) { event.preventDefault(); const noteBase = computerKeyNoteMapping[key]; const fullNoteName = `${noteBase}${startingOctave}`; playNote(fullNoteName); pressedComputerKeys.add(key); } else if (key === 'z') { if (startingOctave > 0) { startingOctave--; dom.octaveDisplay.textContent = startingOctave; createOnScreenKeyboard(); } event.preventDefault(); } else if (key === 'x') { if (startingOctave < 8) { startingOctave++; dom.octaveDisplay.textContent = startingOctave; createOnScreenKeyboard(); } event.preventDefault(); } });
        window.addEventListener('keyup', (event) => { if (!synth || document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') return; const key = event.key.toLowerCase(); if (computerKeyNoteMapping[key] && pressedComputerKeys.has(key)) { event.preventDefault(); const noteBase = computerKeyNoteMapping[key]; const fullNoteName = `${noteBase}${startingOctave}`; releaseNote(fullNoteName); pressedComputerKeys.delete(key); } });
        async function initializeMIDI() { /* ... (same - includes updated error messages) ... */ dom.midiStatus.textContent = "Accessing MIDI..."; if (navigator.requestMIDIAccess) { try { midiAccess = await navigator.requestMIDIAccess({ sysex: false }); dom.midiStatus.textContent = "MIDI Granted. Listening..."; startMIDIListening(); } catch (e) { let specificAdvice = ""; if (e.message && e.message.toLowerCase().includes("permission add-on")) { specificAdvice = " This error often appears in Firefox if MIDI permissions are not set or an add-on like Jazz-MIDI is needed and not configured. Please check your browser's site permissions for MIDI and ensure any required MIDI extensions are active."; } else if (e.name === "SecurityError") { specificAdvice = " MIDI access was denied by a security policy. This can happen if the page is not served over HTTPS, or if MIDI is disabled in browser settings/permissions."; } else { specificAdvice = " Please ensure your MIDI device is connected and check your browser's MIDI settings and site permissions."; } dom.midiStatus.textContent = `MIDI Access Error.${specificAdvice}`; console.error("Could not access MIDI devices:", e.name, e.message, specificAdvice); } } else { dom.midiStatus.textContent = "Web MIDI API not supported in this browser. Use Chrome/Edge for MIDI."; console.warn("Web MIDI API not supported in this browser!"); } }
        function startMIDIListening() { /* ... (same) ... */ if (!midiAccess) return; const inputs = midiAccess.inputs.values(); let deviceFound = false; for (let input = inputs.next(); input && !input.done; input = inputs.next()) { deviceFound = true; input.value.onmidimessage = onMIDIMessage; } if(deviceFound) dom.midiStatus.textContent = "Listening to MIDI devices."; else dom.midiStatus.textContent = "No MIDI inputs found."; midiAccess.onstatechange = (event) => { dom.midiStatus.textContent = `MIDI: ${event.port.name} ${event.port.state}. Re-scan...`; startMIDIListening(); }; }
        function midiNoteToNoteNameAndOctave(midiNote) { /* ... (same) ... */ const noteIndex = midiNote % 12; const octave = Math.floor(midiNote / 12) - 1; return `${noteNamesSharp[noteIndex]}${octave}`; }
        
        function onMIDIMessage(message) { /* ... (MIDI Learn logic and note on/off unchanged) ... */ if (!synth) return; const [command, data1, data2] = message.data; const type = command & 0xF0; const channel = command & 0x0F; if (isGlobalMidiLearnActive && paramKeyToLearn && type === 0xB0) { const ccNumber = data1; const currentParamDef = paramDefinitions[paramKeyToLearn]; midiMappings[ccNumber] = paramKeyToLearn; saveMidiMappings(); console.log(`MIDI LEARN: Mapped CC ${ccNumber} to ${currentParamDef.label}`); dom.midiLearnStatus.textContent = `Learned: CC ${ccNumber} -> ${currentParamDef.label}`; isGlobalMidiLearnActive = false; paramKeyToLearn = null; dom.midiLearnButton.textContent = "MIDI Learn"; dom.midiLearnButton.classList.remove('learn-active'); setTimeout(() => { dom.midiLearnStatus.textContent = ""; }, 2000); } else if (!isGlobalMidiLearnActive && type === 0xB0) { const ccNumber = data1; const ccValue = data2; const mappedParamKey = midiMappings[ccNumber]; if (mappedParamKey) { updateParamFromMidiCC(mappedParamKey, ccValue); } } else if ((type === 0x90 && data2 > 0)) { const noteNameFull = midiNoteToNoteNameAndOctave(data1); const scaledVelocity = data2 / 127; playNote(noteNameFull, scaledVelocity); } else if (type === 0x80 || (type === 0x90 && data2 === 0)) { const noteNameFull = midiNoteToNoteNameAndOctave(data1); releaseNote(noteNameFull); } }
        function updateParamFromMidiCC(paramKey, ccValue) { /* ... (same) ... */ const paramDef = paramDefinitions[paramKey]; if (!paramDef) { console.warn(`MIDI CC: No param def for key ${paramKey}`); return; } const element = dom[paramDef.elementId]; if (!element) { console.warn(`MIDI CC: Element ID ${paramDef.elementId} not found for ${paramKey}`); return; } let normalizedValue; if (paramDef.type === 'range') { const min = paramDef.min; const max = paramDef.max; normalizedValue = (ccValue / 127) * (max - min) + min; element.value = normalizedValue; } else if (paramDef.type === 'checkbox') { normalizedValue = ccValue >= 64; element.checked = normalizedValue; } else if (paramDef.type === 'select') { const optionCount = paramDef.options.length; const optionIndex = Math.floor((ccValue / 127) * (optionCount -1)); normalizedValue = paramDef.options[Math.max(0, Math.min(optionIndex, optionCount - 1))]; element.value = normalizedValue; } element.dispatchEvent(new Event(paramDef.eventToDispatch, { bubbles: true }));}
        function toggleGlobalMidiLearnMode() { /* ... (same) ... */ isGlobalMidiLearnActive = !isGlobalMidiLearnActive; if (isGlobalMidiLearnActive) { dom.midiLearnButton.textContent = "Learning... Click a Control"; dom.midiLearnButton.classList.add('learn-active'); dom.midiLearnStatus.textContent = "Click a synth control to map it."; paramKeyToLearn = null; } else { dom.midiLearnButton.textContent = "MIDI Learn"; dom.midiLearnButton.classList.remove('learn-active'); dom.midiLearnStatus.textContent = paramKeyToLearn ? `Cancelled learn for ${paramDefinitions[paramKeyToLearn]?.label || 'Unknown'}` : ""; paramKeyToLearn = null; setTimeout(() => { if(!isGlobalMidiLearnActive) dom.midiLearnStatus.textContent = ""; }, 2000); } }
        function setupMidiLearnForElement(paramKey) { /* ... (same) ... */ if (!isGlobalMidiLearnActive) return; paramKeyToLearn = paramKey; const paramDef = paramDefinitions[paramKey]; dom.midiLearnButton.textContent = `Listening for CC... (${paramDef.label})`; dom.midiLearnStatus.textContent = `Move MIDI control for: ${paramDef.label}`; console.log(`MIDI LEARN: Waiting for CC for parameter: ${paramDef.label} (Key: ${paramKey})`); }
        function saveMidiMappings() { /* ... (same) ... */ try { localStorage.setItem('syn7h_midiMappings', JSON.stringify(midiMappings)); console.log("MIDI Mappings saved."); } catch (e) { console.error("Error saving MIDI mappings:", e); } }
        function loadMidiMappings() { /* ... (same) ... */ try { const savedMappings = localStorage.getItem('syn7h_midiMappings'); if (savedMappings) { midiMappings = JSON.parse(savedMappings); console.log("MIDI Mappings loaded:", midiMappings); } else { midiMappings = {}; console.log("No saved MIDI mappings found."); } } catch (e) { console.error("Error loading MIDI mappings:", e); midiMappings = {}; } }

        // --- UI Control Event Listeners ---
        dom.startAudioButton.addEventListener('click', async (e) => { e.target.blur(); dom.audioContextMessageOverlay.classList.remove('visible'); const success = await initializeAudio(); if(success) console.log("Audio init OK from Start."); else console.error("Audio init FAILED from Start."); });
        dom.midiLearnButton.addEventListener('click', (e) => { toggleGlobalMidiLearnMode(); e.target.blur(); });
        Object.keys(paramDefinitions).forEach(paramKey => { const definition = paramDefinitions[paramKey]; const element = dom[definition.elementId]; if (element) { const eventType = (definition.type === 'range' || definition.type === 'file') ? 'mousedown' : 'focus'; element.addEventListener(eventType, () => { if (isGlobalMidiLearnActive && !paramKeyToLearn) { setupMidiLearnForElement(paramKey); } }); element.addEventListener('change', (e) => e.target.blur()); if (definition.type === 'range') element.addEventListener('input', (e) => e.target.blur());} else { console.warn(`MIDI Learn Setup: Element ID '${definition.elementId}' for param '${paramKey}' not found.`); }});

        dom.oscType.addEventListener('change', (e) => { updateOscillatorType(); e.target.blur(); });
        const oscParamHandler = (e) => { applyCurrentOscillatorSpecificSettings(dom.oscType.value); e.target.blur(); };
        dom.pwmSpeed.addEventListener('input', (e) => { updateSliderDisplay(dom.pwmSpeed, dom.pwmSpeedDisplay, 'Hz'); oscParamHandler(e); });
        dom.fmHarmonicity.addEventListener('input', (e) => { updateSliderDisplay(dom.fmHarmonicity, dom.fmHarmonicityDisplay, '', 1); oscParamHandler(e);});
        dom.fmModIndex.addEventListener('input', (e) => { updateSliderDisplay(dom.fmModIndex, dom.fmModIndexDisplay, '', 0); oscParamHandler(e);});
        dom.supersawCount.addEventListener('input', (e) => { updateSliderDisplay(dom.supersawCount, dom.supersawCountDisplay, '', 0); oscParamHandler(e);});
        dom.supersawSpread.addEventListener('input', (e) => { updateSliderDisplay(dom.supersawSpread, dom.supersawSpreadDisplay, ' cents', 0); oscParamHandler(e);});
        dom.resonantBodyHarmonicity.addEventListener('input', (e) => { updateSliderDisplay(dom.resonantBodyHarmonicity, dom.resonantBodyHarmonicityDisplay, '', 1); oscParamHandler(e); });
        dom.resonantBodyModIndex.addEventListener('input', (e) => { updateSliderDisplay(dom.resonantBodyModIndex, dom.resonantBodyModIndexDisplay, '', 0); oscParamHandler(e); });
        dom.formantVoiceHarmonicity.addEventListener('input', (e) => { updateSliderDisplay(dom.formantVoiceHarmonicity, dom.formantVoiceHarmonicityDisplay, '', 1); oscParamHandler(e); });
        dom.formantVoiceModIndex.addEventListener('input', (e) => { updateSliderDisplay(dom.formantVoiceModIndex, dom.formantVoiceModIndexDisplay, '', 0); oscParamHandler(e); });
        
        // Granular controls 
        dom.granularFileInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (file && file.type === "audio/wav") { const reader = new FileReader(); reader.onload = (e_reader) => { Tone.Buffer.fromUrl(e_reader.target.result).then(buffer => { grainPlayerBuffer = buffer; if (dom.oscType.value === 'granular') { updateOscillatorType(); } dom.midiLearnStatus.textContent = `Loaded: ${file.name.substring(0,20)}...`; }).catch(err => { console.error("Error loading WAV into Tone.Buffer:", err); dom.midiLearnStatus.textContent = "Error loading WAV."; }); }; reader.readAsDataURL(file); } else if (file) { dom.midiLearnStatus.textContent = "Please select a .wav file."; console.warn("GRANULAR: Non-WAV file selected."); } event.target.blur(); });
        dom.granularLoop.addEventListener('change', (e) => { if(synth && currentActiveSynthType === 'GrainPlayer') synth.loop = e.target.checked; e.target.blur(); });
        dom.granularLoopStart.addEventListener('input', (e) => { updateSliderDisplay(dom.granularLoopStart, dom.granularLoopStartDisplay, '', 2); if(synth && currentActiveSynthType === 'GrainPlayer') synth.loopStart = parseFloat(e.target.value); e.target.blur(); });
        dom.granularLoopEnd.addEventListener('input', (e) => { updateSliderDisplay(dom.granularLoopEnd, dom.granularLoopEndDisplay, '', 2); if(synth && currentActiveSynthType === 'GrainPlayer') synth.loopEnd = parseFloat(e.target.value); e.target.blur(); });
        dom.granularReverse.addEventListener('change', (e) => { if(synth && currentActiveSynthType === 'GrainPlayer') synth.reverse = e.target.checked; e.target.blur(); });
        dom.granularGrainSize.addEventListener('input', (e) => { updateSliderDisplay(dom.granularGrainSize, dom.granularGrainSizeDisplay, 's', 3); if(synth && currentActiveSynthType === 'GrainPlayer') synth.grainSize = parseFloat(e.target.value); e.target.blur(); });
        dom.granularOverlap.addEventListener('input', (e) => { updateSliderDisplay(dom.granularOverlap, dom.granularOverlapDisplay, 's', 3); if(synth && currentActiveSynthType === 'GrainPlayer') synth.overlap = parseFloat(e.target.value); e.target.blur(); });
        dom.granularDetune.addEventListener('input', (e) => { updateSliderDisplay(dom.granularDetune, dom.granularDetuneDisplay, ' cents', 0); if(synth && currentActiveSynthType === 'GrainPlayer') synth.detune = parseFloat(e.target.value); e.target.blur(); });
        dom.granularPlaybackRate.addEventListener('input', (e) => { updateSliderDisplay(dom.granularPlaybackRate, dom.granularPlaybackRateDisplay, 'x', 2); if(synth && currentActiveSynthType === 'GrainPlayer') synth.playbackRate = parseFloat(e.target.value); e.target.blur(); });


        function updateVolumeAndEnvelopes(event) { applyCurrentOscillatorSpecificSettings(dom.oscType.value); if(event && event.target) event.target.blur(); } 
        dom.volume.addEventListener('input', (e) => {updateSliderDisplay(dom.volume, dom.volumeDisplay, 'dB',0); updateVolumeAndEnvelopes(e);});
        dom.ampEnvAttack.addEventListener('input', (e) => { updateSliderDisplay(dom.ampEnvAttack, dom.ampEnvAttackDisplay, 's', 3); updateVolumeAndEnvelopes(e); });
        dom.ampEnvDecay.addEventListener('input', (e) => { updateSliderDisplay(dom.ampEnvDecay, dom.ampEnvDecayDisplay, 's', 2); updateVolumeAndEnvelopes(e); });
        dom.ampEnvSustain.addEventListener('input', (e) => { updateSliderDisplay(dom.ampEnvSustain, dom.ampEnvSustainDisplay, '', 2); updateVolumeAndEnvelopes(e); });
        dom.ampEnvRelease.addEventListener('input', (e) => { updateSliderDisplay(dom.ampEnvRelease, dom.ampEnvReleaseDisplay, 's', 2); updateVolumeAndEnvelopes(e); });

        dom.filterType.addEventListener('change', (e) => {applyCurrentOscillatorSpecificSettings(dom.oscType.value); e.target.blur(); });
        const filterParamHandler = (e) => { applyCurrentOscillatorSpecificSettings(dom.oscType.value); e.target.blur(); };
        dom.filterCutoff.addEventListener('input', (e) => { updateSliderDisplay(dom.filterCutoff, dom.filterCutoffDisplay, 'Hz', 0); filterParamHandler(e); });
        dom.filterResonance.addEventListener('input', (e) => { updateSliderDisplay(dom.filterResonance, dom.filterResonanceDisplay, 'Q'); filterParamHandler(e); });
        dom.filterEnvAttack.addEventListener('input', (e) => { updateSliderDisplay(dom.filterEnvAttack, dom.filterEnvAttackDisplay, 's', 3); filterParamHandler(e); });
        dom.filterEnvDecay.addEventListener('input', (e) => { updateSliderDisplay(dom.filterEnvDecay, dom.filterEnvDecayDisplay, 's', 2); filterParamHandler(e); });
        dom.filterEnvSustain.addEventListener('input', (e) => { updateSliderDisplay(dom.filterEnvSustain, dom.filterEnvSustainDisplay, '', 2); filterParamHandler(e); });
        dom.filterEnvRelease.addEventListener('input', (e) => { updateSliderDisplay(dom.filterEnvRelease, dom.filterEnvReleaseDisplay, 's', 2); filterParamHandler(e); });
        dom.filterEnvAmount.addEventListener('input', (e) => { updateSliderDisplay(dom.filterEnvAmount, dom.filterEnvAmountDisplay, ' oct', 1); filterParamHandler(e); });

        const lfoUpdateHandler = (e) => { updateLFO1Connections(); e.target.blur(); };
        dom.lfo1Enable.addEventListener('change', lfoUpdateHandler); 
        dom.lfo1Wave.addEventListener('change', lfoUpdateHandler); 
        dom.lfo1PulseWidth.addEventListener('input', (e) => { updateSliderDisplay(dom.lfo1PulseWidth, dom.lfo1PulseWidthDisplay, '', 2); if (lfo1 && dom.lfo1Wave.value === 'pulse') lfo1.width.value = parseFloat(dom.lfo1PulseWidth.value); e.target.blur();});
        dom.lfo1PwmFreq.addEventListener('input', (e) => { updateSliderDisplay(dom.lfo1PwmFreq, dom.lfo1PwmFreqDisplay, 'Hz'); if (lfo1 && dom.lfo1Wave.value === 'pwm') lfo1.modulationFrequency.value = parseFloat(dom.lfo1PwmFreq.value); e.target.blur();});
        dom.lfo1Rate.addEventListener('input', (e) => { updateSliderDisplay(dom.lfo1Rate, dom.lfo1RateDisplay, 'Hz'); lfoUpdateHandler(e); });
        dom.lfo1Depth.addEventListener('input', (e) => { updateSliderDisplay(dom.lfo1Depth, dom.lfo1DepthDisplay, '', 2); lfoUpdateHandler(e); });
        dom.lfo1Destination.addEventListener('change', lfoUpdateHandler);

        // Effect Control Listeners
        const effectToggleHandler = (e) => { applyAudioChain(); e.target.blur(); };
        const effectWetHandler = (slider, display, unit, decimals, e) => { updateSliderDisplay(slider, display, unit, decimals); applyAudioChain(); e.target.blur(); };
        const effectParamHandler = (slider, display, unit, decimals, effectNode, paramName, e) => { updateSliderDisplay(slider, display, unit, decimals); if(effectNode && effectNode[paramName] !== undefined) { if(effectNode[paramName].value !== undefined) {effectNode[paramName].value = parseFloat(slider.value); } else {effectNode[paramName] = parseFloat(slider.value);} } e.target.blur(); };
        
        dom.distEnable.addEventListener('change', effectToggleHandler); dom.distAmount.addEventListener('input', (e) => effectParamHandler(dom.distAmount, dom.distAmountDisplay, '', 2, distortionEffect, 'distortion', e)); dom.distWet.addEventListener('input', (e) => effectWetHandler(dom.distWet, dom.distWetDisplay, '', 2, e));
        dom.crusherEnable.addEventListener('change', effectToggleHandler); dom.crusherBits.addEventListener('input', (e) => { updateSliderDisplay(dom.crusherBits, dom.crusherBitsDisplay, ' bits', 0); if(bitCrusherEffect) bitCrusherEffect.bits.value = parseInt(dom.crusherBits.value); e.target.blur(); }); dom.crusherWet.addEventListener('input', (e) => effectWetHandler(dom.crusherWet, dom.crusherWetDisplay, '', 2, e));
        dom.ringModEnable.addEventListener('change', effectToggleHandler); dom.ringModFrequency.addEventListener('input', (e) => effectParamHandler(dom.ringModFrequency, dom.ringModFrequencyDisplay, ' Hz', 0, ringModulatorEffect, 'frequency', e)); dom.ringModWet.addEventListener('input', (e) => effectWetHandler(dom.ringModWet, dom.ringModWetDisplay, '', 2, e));
        dom.chorusEnable.addEventListener('change', effectToggleHandler); dom.chorusRate.addEventListener('input', (e) => effectParamHandler(dom.chorusRate, dom.chorusRateDisplay, 'Hz', 1, chorusEffect.frequency, 'value', e)); dom.chorusDepth.addEventListener('input', (e) => effectParamHandler(dom.chorusDepth, dom.chorusDepthDisplay, '', 2, chorusEffect, 'depth', e)); dom.chorusFeedback.addEventListener('input', (e) => effectParamHandler(dom.chorusFeedback, dom.chorusFeedbackDisplay, '', 2, chorusEffect.feedback, 'value', e)); dom.chorusWet.addEventListener('input', (e) => effectWetHandler(dom.chorusWet, dom.chorusWetDisplay, '', 2, e));
        dom.phaserEnable.addEventListener('change', effectToggleHandler); dom.phaserFrequency.addEventListener('input', (e) => effectParamHandler(dom.phaserFrequency, dom.phaserFrequencyDisplay, 'Hz', 1, phaserEffect.frequency, 'value', e)); dom.phaserOctaves.addEventListener('input', (e) => effectParamHandler(dom.phaserOctaves, dom.phaserOctavesDisplay, '', 1, phaserEffect, 'octaves', e)); dom.phaserBaseFreq.addEventListener('input', (e) => effectParamHandler(dom.phaserBaseFreq, dom.phaserBaseFreqDisplay, 'Hz', 0, phaserEffect, 'baseFrequency', e)); dom.phaserWet.addEventListener('input', (e) => effectWetHandler(dom.phaserWet, dom.phaserWetDisplay, '', 2, e));
        dom.delayEnable.addEventListener('change', effectToggleHandler); dom.delayTime.addEventListener('input', (e) => effectParamHandler(dom.delayTime, dom.delayTimeDisplay, 's', 2, delayEffect.delayTime, 'value', e)); dom.delayFeedback.addEventListener('input', (e) => effectParamHandler(dom.delayFeedback, dom.delayFeedbackDisplay, '', 2, delayEffect.feedback, 'value', e)); dom.delayWet.addEventListener('input', (e) => effectWetHandler(dom.delayWet, dom.delayWetDisplay, '', 2, e));
        dom.pingpongEnable.addEventListener('change', effectToggleHandler); dom.pingpongDelayTime.addEventListener('input', (e) => effectParamHandler(dom.pingpongDelayTime, dom.pingpongDelayTimeDisplay, 's', 2, pingPongDelayEffect.delayTime, 'value', e)); dom.pingpongFeedback.addEventListener('input', (e) => effectParamHandler(dom.pingpongFeedback, dom.pingpongFeedbackDisplay, '', 2, pingPongDelayEffect.feedback, 'value', e)); dom.pingpongWet.addEventListener('input', (e) => effectWetHandler(dom.pingpongWet, dom.pingpongWetDisplay, '', 2, e));
        dom.reverbEnable.addEventListener('change', effectToggleHandler); dom.reverbDecay.addEventListener('input', (e) => { updateSliderDisplay(dom.reverbDecay, dom.reverbDecayDisplay, 's'); if(reverbEffect) reverbEffect.decay = parseFloat(dom.reverbDecay.value); e.target.blur(); }); dom.reverbWet.addEventListener('input', (e) => effectWetHandler(dom.reverbWet, dom.reverbWetDisplay, '', 2, e));


        // --- Initial Page Load ---
        window.addEventListener('load', () => {
            console.log("Window loaded."); 
            dom.octaveDisplay.textContent = startingOctave; 
            createOnScreenKeyboard(); 
            
            updateSliderDisplay(dom.volume, dom.volumeDisplay, 'dB', 0); 
            updateSliderDisplay(dom.ampEnvAttack, dom.ampEnvAttackDisplay, 's', 3); updateSliderDisplay(dom.ampEnvDecay, dom.ampEnvDecayDisplay, 's', 2); updateSliderDisplay(dom.ampEnvSustain, dom.ampEnvSustainDisplay, '', 2); updateSliderDisplay(dom.ampEnvRelease, dom.ampEnvReleaseDisplay, 's', 2);
            updateSliderDisplay(dom.filterCutoff, dom.filterCutoffDisplay, 'Hz', 0); updateSliderDisplay(dom.filterResonance, dom.filterResonanceDisplay, 'Q');
            updateSliderDisplay(dom.filterEnvAttack, dom.filterEnvAttackDisplay, 's', 3); updateSliderDisplay(dom.filterEnvDecay, dom.filterEnvDecayDisplay, 's', 2); updateSliderDisplay(dom.filterEnvSustain, dom.filterEnvSustainDisplay, '', 2); updateSliderDisplay(dom.filterEnvRelease, dom.filterEnvReleaseDisplay, 's', 2); updateSliderDisplay(dom.filterEnvAmount, dom.filterEnvAmountDisplay, ' oct', 1);
            updateSliderDisplay(dom.pwmSpeed, dom.pwmSpeedDisplay, 'Hz'); updateSliderDisplay(dom.fmHarmonicity, dom.fmHarmonicityDisplay, '', 1); updateSliderDisplay(dom.fmModIndex, dom.fmModIndexDisplay, '', 0);
            updateSliderDisplay(dom.supersawCount, dom.supersawCountDisplay, '', 0); updateSliderDisplay(dom.supersawSpread, dom.supersawSpreadDisplay, ' cents', 0);
            updateSliderDisplay(dom.resonantBodyHarmonicity, dom.resonantBodyHarmonicityDisplay, '',1); updateSliderDisplay(dom.resonantBodyModIndex, dom.resonantBodyModIndexDisplay, '', 0);
            updateSliderDisplay(dom.formantVoiceHarmonicity, dom.formantVoiceHarmonicityDisplay, '',1); updateSliderDisplay(dom.formantVoiceModIndex, dom.formantVoiceModIndexDisplay, '', 0);
            updateSliderDisplay(dom.granularGrainSize, dom.granularGrainSizeDisplay, 's', 3); updateSliderDisplay(dom.granularOverlap, dom.granularOverlapDisplay, 's', 3); updateSliderDisplay(dom.granularDetune, dom.granularDetuneDisplay, 'cents', 0); updateSliderDisplay(dom.granularPlaybackRate, dom.granularPlaybackRateDisplay, 'x',2);
            updateSliderDisplay(dom.granularLoopStart, dom.granularLoopStartDisplay, '', 2); updateSliderDisplay(dom.granularLoopEnd, dom.granularLoopEndDisplay, '', 2);
            updateSliderDisplay(dom.lfo1Rate, dom.lfo1RateDisplay, 'Hz'); updateSliderDisplay(dom.lfo1Depth, dom.lfo1DepthDisplay, '', 2);
            updateSliderDisplay(dom.lfo1PulseWidth, dom.lfo1PulseWidthDisplay, '', 2); updateSliderDisplay(dom.lfo1PwmFreq, dom.lfo1PwmFreqDisplay, 'Hz');
            updateSliderDisplay(dom.distAmount, dom.distAmountDisplay, '', 2); updateSliderDisplay(dom.distWet, dom.distWetDisplay, '', 2);
            updateSliderDisplay(dom.crusherBits, dom.crusherBitsDisplay, 'bits', 0); updateSliderDisplay(dom.crusherWet, dom.crusherWetDisplay, '', 2);
            updateSliderDisplay(dom.ringModFrequency, dom.ringModFrequencyDisplay, 'Hz', 0); updateSliderDisplay(dom.ringModWet, dom.ringModWetDisplay, '', 2);
            updateSliderDisplay(dom.chorusRate, dom.chorusRateDisplay, 'Hz'); updateSliderDisplay(dom.chorusDepth, dom.chorusDepthDisplay, '', 2); updateSliderDisplay(dom.chorusFeedback, dom.chorusFeedbackDisplay, '', 2); updateSliderDisplay(dom.chorusWet, dom.chorusWetDisplay, '', 2);
            updateSliderDisplay(dom.phaserFrequency, dom.phaserFrequencyDisplay, 'Hz'); updateSliderDisplay(dom.phaserOctaves, dom.phaserOctavesDisplay, '', 1); updateSliderDisplay(dom.phaserBaseFreq, dom.phaserBaseFreqDisplay, 'Hz', 0); updateSliderDisplay(dom.phaserWet, dom.phaserWetDisplay, '', 2);
            updateSliderDisplay(dom.delayTime, dom.delayTimeDisplay, 's', 2); updateSliderDisplay(dom.delayFeedback, dom.delayFeedbackDisplay, '', 2); updateSliderDisplay(dom.delayWet, dom.delayWetDisplay, '', 2);
            updateSliderDisplay(dom.pingpongDelayTime, dom.pingpongDelayTimeDisplay, 's', 2); updateSliderDisplay(dom.pingpongFeedback, dom.pingpongFeedbackDisplay, '', 2); updateSliderDisplay(dom.pingpongWet, dom.pingpongWetDisplay, '', 2);
            updateSliderDisplay(dom.reverbDecay, dom.reverbDecayDisplay, 's'); updateSliderDisplay(dom.reverbWet, dom.reverbWetDisplay, '', 2);
            
            // Initial visibility of contextual controls
            dom.pwmControls.classList.toggle('hidden', dom.oscType.value !== 'pwm'); 
            dom.fmControls.classList.toggle('hidden', dom.oscType.value !== 'fmsine');
            dom.supersawControls.classList.toggle('hidden', dom.oscType.value !== 'supersaw');
            dom.resonantBodyControls.classList.toggle('hidden', dom.oscType.value !== 'resonantbody');
            dom.formantVoiceControls.classList.toggle('hidden', dom.oscType.value !== 'formantvoice');
            dom.granularControls.classList.toggle('hidden', dom.oscType.value !== 'granular');
            dom.lfo1PulseWidthControls.classList.toggle('hidden', dom.lfo1Wave.value !== 'pulse'); 
            dom.lfo1PwmFreqControls.classList.toggle('hidden', dom.lfo1Wave.value !== 'pwm'); 
            
            showMessage(dom.audioContextMessageOverlay, "Click 'Start' to enable audio.", "Start", async () => {
                const success = await initializeAudio();
                if (!success) console.error("Initial audio setup FAILED after user interaction on load.");
                else console.log("Initial audio setup OK after user interaction on load.");
            });
        });
    </script>
</body>
</html>
